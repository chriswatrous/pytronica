To Do:
    Oscillators:
        Square
        Triangle
        Sin
        White Noise
        Quality Saw
        Quality Square
        Quality Triangle
    Synthesizers:
        basic subtractive (standard analog modeling)
        additive
            with exp decaying sine waves, which would be easy to implement as a recurance relation
        FM
        something like Absynth
        something like Massive
        that multi-saw synth I made in Reaktor
        study synths in Reaktor and in FL Studio
    Envelopes:
        AR
        others
        arbitrary control signal
        ExpLinDecay:
            x[n] = a*x[n-1] - b
            OR
            v[n] = v[n-1] - a
            w[n] = b*w[n-1]
            x[n] = w[n] + w[n]
        explore recurance relations to see what curves I can produce
    Modifiers:
        Add
        MulAdd
        Take
        MemoryDelay
        ProcessDelay
        Convolution
        Reverb (algorithmic)
        Interpolating Delay
        Chorus
        Phlanger
        delay with feedback
        waveshapers:
            Clip
            SinShape
            Saturate
    Filters:
        1 pole low pass
        1 pole high pass
        2 pole low pass
        2 pole band pass
        2 pole high pass
        maybe biquad, which could be used to create any other type of filter
        parametric EQ
        filters that can take signals as their input parameters
    Combiners:
        AmpMod (multiply signals, total length is length of the shortest signal)
        Repeat (repeats a sound at regular intervals)
    Stereo:
        stereo reverb, chorus, phlanger, synths, etc.
    make sure all object can handle splitting and recombining of the signal paths
    in general all parameters should be able to take signals or constants as inputs
    add comments / documentation
    delay allocation of bufferes until needed, free when done
    better note mini-language: '3 C D F A Ab C Eb -G' instead of 'C3 D3 F3 A3 Ab3 C4 Eb4 G3'
    measure running time of all Signal classes and report as % of real time
    play_synth function that would take a synth, notes, rhythms, durations, other params, and return a Compose
    bug: finally clause in Signal.play() doesn't execute properly on KeyboardInterrupt
    make Layer like class called Mul to replace existing Mul and AmpMod
    Signal.wavwrite()
    FadeOut
    operator divide for dividing by constants
    Take, Drop, and Slice classes, git rid of length argument in Saw
    relative time for Compose and Controller: set_relative_time(), set_absolute_time(), set_time()
    Signal.rawwrite() improve error handling, allow writing to stdout
    Controller.hold(), Controller.expto(), Controller.jumpto()
    make functions void if they will never throw exceptions
    ADSREnvelope
    rename Signal.Pan() -> Signal.pan()
    look into having Chain derive from Compose

Doing:
    new architecture that allows signals to be used with more than one input, even if the signals are used
        at different times

Done:
    Layer (adds sounds together at the same time, total length is length of the longest signal)
    Decay only envelop
    AmpMod
    Compose (adds sounds together at different times)
    split audio.pyx into multiple files
    call aplay from with the program; allow user to kill playback with ^C
    make "unit tests" that would play short sounds to test functionality
    make aplay exit properly
    report clipping
    change design to allow for stereo
    overload arithmetic operators for signals
    LinearDecay
    clean up unit tests
    add helper methods to Signal that would allow code like this: Saw(220).pan(-.5) + Saw(221).pan(.5)
    "add" method for Layer
    operator subtract
    test error conditions
    get rid of Mul and AmpMod
    Signal.rawwrite()
    Controller with lineto
