To Do:
    Oscillators:
        Square
        Triangle
        Sin
        White Noise
        Quality Saw
        Quality Square
        Quality Triangle
    Synthesizers:
        basic subtractive (standard analog modeling)
        additive
            with exp decaying sine waves, which would be easy to implement as a recurance relation
        FM
        something like Absynth
        something like Massive
        that multi-saw synth I made in Reaktor
        study synths in Reaktor and in FL Studio
    Envelopes:
        AR
        others
        arbitrary control signal
        ExpLinDecay:
            x[n] = a*x[n-1] - b
            OR
            v[n] = v[n-1] - a
            w[n] = b*w[n-1]
            x[n] = w[n] + w[n]
        explore recurance relations to see what curves I can produce
    Modifiers:
        Add
        MulAdd
        Take
        MemoryDelay
        ProcessDelay
        Convolution
        Reverb (algorithmic)
        Interpolating Delay
        Chorus
        Phlanger
        delay with feedback
        waveshapers:
            Clip
            SinShape
            Saturate
    Filters:
        1 pole low pass
        1 pole high pass
        2 pole low pass
        2 pole band pass
        2 pole high pass
        maybe biquad, which could be used to create any other type of filter
        parametric EQ
        filters that can take signals as their input parameters
    Stereo:
        stereo reverb, chorus, phlanger, synths, etc.
    make sure all object can handle splitting and recombining of the signal paths
    in general all parameters should be able to take signals or constants as inputs
    add comments / documentation
    delay allocation of bufferes until needed, free when done
    better note mini-language: '3 C D F A Ab C Eb -G' instead of 'C3 D3 F3 A3 Ab3 C4 Eb4 G3'
        '2 C +D +F +A -D +Eb +G +Bb'
    measure running time of all Signal classes and report as % of real time
    play_synth function that would take a synth, notes, rhythms, durations, other params, and return a Compose
    bug: finally clause in Generator.play() doesn't execute properly on KeyboardInterrupt
    FadeOut
    Take, Drop, and Slice classes, git rid of length argument in Saw
    relative time for Compose and Controller: set_relative_time(), set_absolute_time(), set_time()
    Signal.rawwrite() improve error handling, allow writing to stdout
    Controller.hold(), Controller.expto(), Controller.jumpto()
    ADSREnvelope
    rename internal/private methods and fields to start with underscore
    clip reporting options: none, end, instant
    make sure every song within project adds pytronica/lib to the path from with in the code
        don't depend on $PYTHONPATH
    new architecture:
        test error conditions
        Compose: make sure memory is freed properly when an input is done processing
        for any Generator where the length of self is longer than the length of one of it's inputs:
            make sure the inputs are deleted when they are done being used, so that the memory can be freed by gc
    make SampleBuffer class that just handles allocating and freeing the buffer memory
    try without node recycling and see if it really makes a difference 
    make Generator.measure_render_rate() to complement measure_time()
    Extend class that would make a finite Generator longer or infinite
    apply partial loop unrolling to everything (if more speed is needed)
    every Generator that takes inputs needs to do something intelligent with mlength (mostly keep it the same)
    build pytronica into a single .so file using setup.py
    Generator.fft() that uses GNU octave to display a fft graph of the sound
    Sine oscilator

Doing:

Done:
    Layer (adds sounds together at the same time, total length is length of the longest signal)
    Decay only envelop
    AmpMod
    Compose (adds sounds together at different times)
    split audio.pyx into multiple files
    call aplay from with the program; allow user to kill playback with ^C
    make "unit tests" that would play short sounds to test functionality
    make aplay exit properly
    report clipping
    change design to allow for stereo
    overload arithmetic operators for signals
    LinearDecay
    clean up unit tests
    add helper methods to Signal that would allow code like this: Saw(220).pan(-.5) + Saw(221).pan(.5)
    "add" method for Layer
    operator subtract
    test error conditions
    get rid of Mul and AmpMod
    Signal.rawwrite()
    Controller with lineto
    new architecture:
        linked lists of sample buffers
        recycle linked list nodes
        move BufferNode to separate file
        replace Saw with Saw2 from the new architecture
        move NoOp and Silence to a new file
        adapt Layer to the new architecture
        adapt Multiply to new architecture
        make BufferIter class that handles getting next BufferNode
        adapt ExpDecay and LinearDecay to new architecture
        update NoOp and Silence to use BufferIter
        adapt Compose to new architecture
        adapt Chain to new architecture
        adapt Controller to new architecture
        operator subtract for new architecture
    eliminate all unsafe casting
    operator divide for dividing by constants
    rename Generator.rawwrite() -> raw_write()
    Generator.wav_write()
    Generator.audacity()
    Generator.playx()
    replace issubclass with isinstance
    make sure all files import future division
